import inspect
from abc import ABC

class AbstractMetaclass(ABC):
    @staticmethod
    def create(name, mro):
        globals().update({el.__name__: el for el in mro[0]})
        if len(mro[0]) != 0:
            bases = ','.join([base.__name__ for base in mro[0]])
        else:
            bases = ''

        exec(f'class {name}({bases}):\n\tpass')
        return eval(f'{name}')
        # bases = tuple([base.__name__ for base in mro[0]])
        # return type(name, bases, {})


class AbstractClass(ABC):
    @staticmethod
    def create(name, mro):
        globals().update({el.__name__: el for el in mro[0]})
        if len(mro[0]) != 0:
            bases = ','.join([base.__name__ for base in mro[0]])
        else:
            bases = ''

        if mro[1]:
            globals().update({mro[1].__name__: mro[1]})
            meta = 'metaclass=' + mro[1].__name__
        else:
            meta = ''

        if bases != '':
            str_ = bases + ", " + meta
        else:
            str_ = meta
        exec(f"class {name}({str_}):\n\tpass")
        return eval(f"{name}")


def create_class_base(name, mro=None):
    if mro[1]:
        template = AbstractClass.create(name, mro)
    else:
        template = AbstractClass.create(name, mro)
    return template


def set_class_attrs(cls, attributes=None):
    if attributes is None:
        return cls

    for el in attributes:
        if el[1] != None:
            try:
                if el[2] == "static method":
                    setattr(cls, el[0], staticmethod(el[1]))
                elif el[2] == "class method":
                    setattr(cls, el[0], classmethod(el[1]))
                else:
                    setattr(cls, el[0], el[1])
            except AttributeError:
                continue
    return cls


def create_class(name, mro=None, attributes=None):
    if mro[1]:
        template = AbstractClass.create(name, mro)
    else:
        template = AbstractMetaclass.create(name, mro)
    if attributes is None:
        return template

    for el in attributes:
        if el[0] == "__dict__" or el[0] == "__weakref__":
            continue
        if el[1] != None:
            try:
                if el[2] == "static method":
                    setattr(template, el[0], staticmethod(el[1]))
                elif el[2] == "class method":
                    setattr(template, el[0], classmethod(el[1]))
                else:
                    setattr(template, el[0], el[1])
            except AttributeError:
                continue

    return template


def create_instance(type_, fields):
    instance = type_.__new__(type_)
    for el in fields:
        setattr(instance, el, fields[el])

    return instance


def cell_factory(el):
    inner_el = el
    def inner():
        return inner_el

    return inner.__closure__[0]


def get_code(obj):
    lines = inspect.getsourcelines(obj)[0]
    indent = len(lines[0]) - len(lines[0].lstrip())

    new_lines = []
    for line in lines:
        if len(line) >= indent:
            line = line[indent:]

        new_lines.append(line)
    return '\n'.join(new_lines)